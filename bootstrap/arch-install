#!/usr/bin/env bash
# Author: Brennan Fee
#
# URL to install: bash <(curl -fsSL https://git.io/vNDOZ)
#
# Bash "strict" mode, -o pipefail removed
set -eu
IFS=$'\n\t'

### Global Variables
DEBUG=0

# Colors
Bold=$(tput bold)
Underline=$(tput sgr 0 1)
Reset=$(tput sgr0)
Red=$(tput setaf 1)
Green=$(tput setaf 2)
Yellow=$(tput setaf 3)
Blue=$(tput setaf 4)
Purple=$(tput setaf 5)
Cyan=$(tput setaf 6)
White=$(tput setaf 7)

# Bold Colors
BRed=${Bold}${Red}
BGreen=${Bold}${Green}
BYellow=${Bold}${Yellow}
BBlue=${Bold}${Blue}
BPurple=${Bold}${Purple}
BCyan=${Bold}${Cyan}
BWhite=${Bold}${White}

# Editor
## TODO: Do I need this?
if [[ -f /usr/bin/vim ]]; then
    EDITOR="vim"
elif [[ -f /usr/bin/vi ]]; then
    EDITOR="vi"
elif [[ -z $EDITOR ]]; then
    EDITOR="nano"
fi

# Paths
WORKING_DIR=`pwd`
SCRIPT=`realpath $0`
SCRIPT_PATH=`dirname $SCRIPT`
LOG="{$WORKING_DIR/`basename ${0}`.log"
[[ -f $LOG ]] && rm -f $LOG

# Flags
SYS_ARCH=`uname -m` # Architecture (x86_64)
UEFI=0
XPINGS=0 # CONNECTION CHECK

# Script variables
KEYMAP="us"

# User provided variables
HOST_NAME="computer"
KERNEL_VERSION="default"
DUAL_DISK=0
MAIN_DISK="/dev/sda"
SECOND_DISK=""

### Common Helper Functions

print_line() {
    printf "%$(tput cols)s\n"|tr ' ' '-'
}

print_title() {
    clear
    print_line
    echo -e "# ${Bold}$1${Reset}"
    print_line
    echo ""
}

print_info() {
    #Console width number
    T_COLS=`tput cols`
    echo -e "${Bold}$1${Reset}\n" | fold -sw $(( $T_COLS - 18 )) | sed 's/^/\t/'
}

print_warning() {
    T_COLS=`tput cols`
    echo -e "${BYellow}$1${Reset}\n" | fold -sw $(( $T_COLS - 1 ))
}

error_msg() {
    echo -e "${Red}${1}${Reset}"
    exit 1
}

pause_function() {
    print_line
    read -e -sn 1 -p "Press enter to continue..."
}

pause_if_debug() {
    if [[ $DEBUG = 1 ]]; then
        read -e -sn 1 -p "PAUSED - Press ener to continue..."
    fi
}

invalid_option() {
    print_line
    echo "Invalid option. Try another one."
    pause_function
}

contains_element() {
    #check if an element exist in a string
    for e in "${@:2}"; do [[ $e == $1 ]] && break; done;
}

print_summary() {
    print_title "Summary"
    print_info "Below is a summary of your selections and any auto-detected system information.  If anything is wrong cancel out now with Ctrl-C.  If you continue the installation will begin and will only prompt again during user creation near the end."
    print_line
    if [[ $UEFI = 1 ]]; then
        echo "The machine architecture is $SYS_ARCH and UEFI has been found."
    else
        echo "The machine architecture is $SYS_ARCH and a BIOS has been found."
    fi

    echo "The hostname selected is $HOST_NAME"

    case "$KERNEL_VERSION" in
        "lts")
            echo "The LTS kernel will be installed."
            ;;
        "hard")
            echo "The hardened kernel will be installed."
            ;;
        *)
            echo "The default kernel will be installed."
            ;;
    esac

    echo ""
    if [[ $DUAL_DISK = 0 ]]; then
        echo "This is a single disk system so installation of all files will happen to $MAIN_DISK."
    else
        echo "This is a dual disk system."
        echo "The main disk is $MAIN_DISK."
        echo "The second disk is $SECOND_DISK."
    fi

    echo ""
    pause_function
}

arch_chroot() {
    arch-chroot /mnt /bin/bash -c "${1}"
}

is_package_installed() {
    #check if a package is already installed
    for PKG in $1; do
        pacman -Q $PKG &> /dev/null && return 0;
    done
    return 1
}

### Verification Functions

check_root() {
    echo "Checking root permissions..."

    if [[ "$(id -u)" != "0" ]]; then
        error_msg "ERROR! You must execute the script as the 'root' user."
    fi
}

check_archlinux() {
    if [[ ! -e /etc/arch-release ]]; then
        error_msg "ERROR! You must execute the script on Arch Linux."
    fi
}

check_boot_system() {
    if [[ "$(cat /sys/class/dmi/id/sys_vendor)" == 'Apple Inc.' ]] || [[ "$(cat /sys/class/dmi/id/sys_vendor)" == 'Apple Computer, Inc.' ]]; then
        modprobe -r -q efivars || true  # if MAC
    else
        modprobe -q efivarfs            # all others
    fi

    if [[ -d "/sys/firmware/efi/" ]]; then
        ## Mount efivarfs if it is not already mounted
        if [[ -z $(mount | grep /sys/firmware/efi/efivars) ]]; then
            mount -t efivarfs efivarfs /sys/firmware/efi/efivars
        fi
        UEFI=1
    else
        UEFI=0
    fi
}

check_connection(){
    XPINGS=$(( $XPINGS + 1 ))
    connection_test() {
        ping -q -w 1 -c 1 `ip r | grep default | awk 'NR==1 {print $3}'` &> /dev/null && return 1 || return 0
    }
    WIRED_DEV=`ip link | grep "ens\|eno\|enp" | awk '{print $2}' | sed 's/://' | sed '1!d'`
    WIRELESS_DEV=`ip link | grep wlp | awk '{print $2}' | sed 's/://' | sed '1!d'`
    if connection_test; then
        print_warning "ERROR! Connection not Found."
        print_info "Network Setup"
        local _connection_opts=("Wired Automatic" "Wired Manual" "Wireless" "Configure Proxy" "Skip")
        PS3="Enter your option: "
        select CONNECTION_TYPE in "${_connection_opts[@]}"; do
            case "$REPLY" in
                1)
                    systemctl start dhcpcd@${WIRED_DEV}.service
                    break
                    ;;
                2)
                    systemctl stop dhcpcd@${WIRED_DEV}.service
                    read -p "IP Address: " IP_ADDR
                    read -p "Submask: " SUBMASK
                    read -p "Gateway: " GATEWAY
                    ip link set ${WIRED_DEV} up
                    ip addr add ${IP_ADDR}/${SUBMASK} dev ${WIRED_DEV}
                    ip route add default via ${GATEWAY}
                    $EDITOR /etc/resolv.conf
                    break
                    ;;
                3)
                    wifi-menu ${WIRELESS_DEV}
                    break
                    ;;
                5)
                    break
                    ;;
                *)
                    invalid_option
                    ;;
            esac
        done
        if [[ $XPINGS -gt 2 ]]; then
            print_warning "Can't establish connection. exiting..."
            exit 1
        fi
        [[ $REPLY -ne 5 ]] && check_connection
    fi
}

### Prompts / User interaction

ask_for_hostname() {
    print_title "Hostname"
    print_info "Pick a hostname for this machine."
    read -p "Hostname [ex: archlinux]: " HOST_NAME
    if [[ $HOST_NAME = "" ]]; then
        HOST_NAME="archlinux"
    fi
}

ask_for_main_disk() {
    echo "Determining main disk..."
    devices_list=(`lsblk --nodeps --noheading --list --exclude 1,11,7 | awk '{print "/dev/" $1}'`);

    if [[ ${#devices_list[@]} = 1 ]]; then
        device=${devices_list[0]}
    else
        print_title "Main Disk Selection"
        print_info "Select which disk to use for the main installation (where root and boot will go)."
        lsblk --nodeps --list --exclude 1,11,7 --output "name,size,type"
        echo ""
        PS3="Enter your option: "
        echo -e "Select main drive:\n"
        select device in "${devices_list[@]}"; do
            if contains_element "${device}" "${devices_list[@]}"; then
                break
            else
                invalid_option
            fi
        done
    fi
    MAIN_DISK=$device
}

ask_for_second_disk() {
    device_count=(`lsblk --nodeps --noheading --list --exclude 1,11,7 | awk '{print "/dev/" $1}' | grep -vc $MAIN_DISK || true`);

    if [[ $device_count = 0 ]]; then
        DUAL_DISK=0
        SECOND_DISK=""
        return
    fi

    print_title "Second Disk Selection"
    print_info "This script can support a two-disk installation.  The file system layout is different in this case."
    read -p "Do you want to use a dual disk setup? (y/N) " SELECT_SECOND
    if [[ $SELECT_SECOND = "" ]]; then
        SELECT_SECOND="N"
    fi

    if [[ $SELECT_SECOND = "n" ]] || [[ $SELECT_SECOND = "N" ]]; then
        DUAL_DISK=0
        SECOND_DISK=""
        return
    fi

    lsblk --nodeps --list --exclude 1,11,7 --output "name,size,type"
    devices_list=(`lsblk --nodeps --noheading --list --exclude 1,11,7 | awk '{print "/dev/" $1}' | grep -v $MAIN_DISK`);
    echo ""
    PS3="Enter your option: "
    echo -e "Select second drive:\n"
    select device in "${devices_list[@]}"; do
        if contains_element "${device}" "${devices_list[@]}"; then
            break
        else
            invalid_option
        fi
    done

    DUAL_DISK=1
    SECOND_DISK=$device
}

ask_for_kernel_level() {
    print_title "Kernel Selection"
    print_info "Select which linux kernel to install. The LTS version is generally prefered and more stable."
    version_list=("linux (default)" "linux-lts (long term support)" "linux-hardened (security features)");
    PS3="Enter your option: "
    echo -e "Select linux version to install\n"
    select VERSION in "${version_list[@]}"; do
        if contains_element "$VERSION" "${version_list[@]}"; then
            if [ "linux (default)" == "$VERSION" ];then
                KERNEL_VERSION="default"
            elif [ "linux-lts (long term support)" == "$VERSION" ];then
                KERNEL_VERSION="lts"
            elif [ "linux-hardened (security features)" == "$VERSION" ];then
                KERNEL_VERSION="hard"
            fi
            break
        else
            invalid_option
        fi
    done
}

### Installation/configuration functions

configure_mirrorlist(){
    echo "Configuring repository mirrorlist"

    url="https://www.archlinux.org/mirrorlist/?country=US&protocol=https&use_mirror_status=on"

    tmpfile=$(mktemp --suffix=-mirrorlist)

    # Get latest mirror list and save to tmpfile
    curl -so ${tmpfile} ${url}
    sed -i 's/^#Server/Server/g' ${tmpfile}

    # Backup and replace current mirrorlist file (if new file is non-zero)
    if [[ -s ${tmpfile} ]]; then
        echo "  Backing up the original mirrorlist..."
        rm -f "/etc/pacman.d/mirrorlist.orig"
        mv -i "/etc/pacman.d/mirrorlist" "/etc/pacman.d/mirrorlist.orig"

        echo "  Rotating the new list into place..."
        mv -i ${tmpfile} "/etc/pacman.d/mirrorlist"
    else
      echo "  Unable to update, could not download list."
    fi

    # better repo should go first
    cp /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.tmp
    rankmirrors /etc/pacman.d/mirrorlist.tmp > /etc/pacman.d/mirrorlist
    rm /etc/pacman.d/mirrorlist.tmp

    # allow global read access (required for non-root yaourt execution)
    chmod +r /etc/pacman.d/mirrorlist
    #$EDITOR /etc/pacman.d/mirrorlist
}

unmount_partitions(){
    mounted_partitions=(`lsblk | grep /mnt | awk '{print $7}' | sort -r`)
    swapoff -a
    for i in ${mounted_partitions[@]}; do
        umount $i
    done
}

create_partitions(){
    echo "Creating partitions"

    echo "  Main disk"
    # Clear out the partitions
    sgdisk --zap $MAIN_DISK
    if [[ $UEFI = 1 ]]; then
        # EFI & Boot partition (2gb)
        sgdisk -n 1:2048:4196351 -c 1:"BOOT" -t 1:ef00 $MAIN_DISK
        # The rest of the disk is for LVM
        sgdisk -n 2:4196352:0 -c 2:"LVM" -t 2:8e00 $MAIN_DISK
    else
        # BIOS partition (1mb)
        sgdisk -n 1:2048:4095 -c 1:"BIOS" -t 1:ef02 $MAIN_DISK
        # The rest of the disk is for LVM
        sgdisk -n 2:4096:0 -c 2:"LVM" -t 2:8e00 $MAIN_DISK
    fi

    if [[ $DUAL_DISK = 1 ]]; then
        echo "  Second disk"
        sgdisk --zip $SECOND_DISK
        # LVM partition (entire disk)
        sgdisk -n 1:2048:0 -c 1:"LVM_SECOND" -t 1:8e00 $SECOND_DISK
    fi
}

setup_lvm() {
    echo "Setting up LVM"

    pvcreate "${MAIN_DISK}2"
    vgcreate "vg_main" "${MAIN_DISK}2"

    if [[ $DUAL_DISK = 0 ]]; then
        lvcreate -l 10%VG "vg_main" -n lv_var
        lvcreate -l 30%VG "vg_main" -n lv_root
        lvcreate -l 40%VG "vg_main" -n lv_home
        lvcreate -l 10%VG "vg_main" -n lv_data
    else
        pvcreate "${SECOND_DISK}1"
        vgcreate "vg_second" "${SECOND_DISK}1"

        lvcreate -l 20%VG "vg_main" -n lv_var
        lvcreate -l 60%VG "vg_main" -n lv_root
        lvcreate -l 50%VG "vg_second" -n lv_home
        lvcreate -l 30%VG "vg_second" -n lv_data
    fi
}

format_partitions() {
    echo "Formatting partitions"

    if [[ $UEFI = 1 ]]; then
        # Format the EFI partition
        #mkfs.vfat -F32 "${MAIN_DISK}1"
        mkfs.ext4 "${MAIN_DISK}1"
    fi

    # Now the LVM partitions...
    mkfs.ext4 "/dev/mapper/vg_main-lv_var"
    mkfs.ext4 "/dev/mapper/vg_main-lv_root"
    if [[ $DUAL_DISK = 0 ]]; then
        mkfs.ext4 "/dev/mapper/vg_main-lv_home"
        mkfs.ext4 "/dev/mapper/vg_main-lv_data"
    else
        mkfs.ext4 "/dev/mapper/vg_second-lv_home"
        mkfs.ext4 "/dev/mapper/vg_second-lv_data"
    fi
}

mount_partitions() {
    echo "Mounting partitions"

    # First load the root
    mount -t ext4 -o defaults,rw,relatime,errors=remount-ro /dev/mapper/vg_main-lv_root /mnt

    # Create the paths for the other mounts
    mkdir -p "/mnt/boot"
    mkdir -p "/mnt/var"
    mkdir -p "/mnt/home"
    mkdir -p "/mnt/data"

    if [[ $UEFI = 1 ]]; then
        #mount -t vfat -o defaults,rw,relatime,utf8,errors=remount-ro "${MAIN_DISK}1" "/mnt/boot"
        mount -t ext4 -o defaults,rw,relatime,errors=remount-ro "${MAIN_DISK}1" "/mnt/boot"
    fi

    # Swap file
    total_memory=`grep MemTotal /proc/meminfo | awk '{print ($2/1024)*1.5}' | sed 's/\..*//'`
    fallocate -l ${total_memory}M /mnt/swapfile
    chmod 600 /mnt/swapfile
    mkswap /mnt/swapfile
    swapon /mnt/swapfile

    # Mount others
    mount -t ext4 -o defaults,rw,relatime /dev/mapper/vg_main-lv_var /mnt/var
    if [[ $DUAL_DISK = 0 ]]; then
        mount -t ext4 -o defaults,rw,relatime /dev/mapper/vg_main-lv_home /mnt/home
        mount -t ext4 -o defaults,rw,relatime /dev/mapper/vg_main-lv_data /mnt/data
    else
        mount -t ext4 -o defaults,rw,relatime /dev/mapper/vg_second-lv_home /mnt/home
        mount -t ext4 -o defaults,rw,relatime /dev/mapper/vg_second-lv_data /mnt/data
    fi
}

install_base_system() {
    echo "Installing base system"

    pacman -Sy --noconfirm archlinux-keyring

    # Install kernel
    case "$KERNEL_VERSION" in
        "lts")
            pacman --noconfirm -Sg base | cut -d ' ' -f 2 | sed s/\^linux\$/linux-lts/g | pacstrap /mnt - linux-lts-headers
            ;;
        "hard")
            pacman --noconfirm -Sg base | cut -d ' ' -f 2 | sed s/\^linux\$/linux-hardened/g | pacstrap /mnt - linux-hardened-headers
            ;;
        *)
            pacstrap /mnt base linux-headers
            ;;
    esac

    pacstrap /mnt base-devel parted btrfs-progs f2fs-tools net-tools dosfstools
    [[ $? -ne 0 ]] && error_msg "Installing base system to /mnt failed. Check error messages above."

    local PTABLE=`parted -l | grep "gpt"`
    [[ -n $PTABLE ]] && pacstrap /mnt gptfdisk

    WIRELESS_DEV=`ip link | grep wl | awk '{print $2}' | sed 's/://' | sed '1!d'`
    if [[ -n $WIRELESS_DEV ]]; then
        pacstrap /mnt iw wireless_tools wpa_actiond wpa_supplicant dialog
    fi

    WIRED_DEV=`ip link | grep "ens\|eno\|enp" | awk '{print $2}' | sed 's/://' | sed '1!d'`
    if [[ -n $WIRED_DEV ]]; then
        arch_chroot "systemctl enable dhcpcd@${WIRED_DEV}.service"
    fi

    # Remaining tools
    pacstrap /mnt git vim openssh ansible

    # Set the ssh service to be enabled
    arch_chroot "systemctl enable sshd.service"
}

configure_keymap() {
    echo "Configure keymap"
    echo "KEYMAP=$KEYMAP" > /mnt/etc/vconsole.conf
}

configure_fstab() {
    echo "Write fstab"

    if [[ $UEFI -eq 1 ]]; then
        genfstab -t PARTUUID -p /mnt >> /mnt/etc/fstab
    else
        genfstab -U -p /mnt >> /mnt/etc/fstab
    fi
    [[ -f /mnt/swapfile ]] && sed -i "s/\\/mnt//" /mnt/etc/fstab
}

configure_hostname() {
    echo "Setup hostname"

    echo "$HOST_NAME" > /mnt/etc/hostname
    arch_chroot "sed -i '/127.0.0.1/s/$/ '${HOST_NAME}'/' /etc/hosts"
    arch_chroot "sed -i '/::1/s/$/ '${HOST_NAME}'/' /etc/hosts"
}

configure_timezone() {
    echo "Configuring timezone"

    arch_chroot "ln -sf /usr/share/zoneinfo/US/Central /etc/localtime"
    arch_chroot "sed -i '/#NTP=/d' /etc/systemd/timesyncd.conf"
    arch_chroot "sed -i 's/#Fallback//' /etc/systemd/timesyncd.conf"
    arch_chroot "echo \"FallbackNTP=0.pool.ntp.org 1.pool.ntp.org 0.us.pool.ntp.org\" >> /etc/systemd/timesyncd.conf"
    arch_chroot "systemctl enable systemd-timesyncd.service"
}

configure_clock() {
    echo "Configuring clock"
    arch_chroot "hwclock --systohc --utc";
}

configure_locale() {
    echo "Configuring locale"
    echo "LANG=en_US.UTF-8" > /mnt/etc/locale.conf
    arch_chroot "sed -i 's/# en_US.UTF-8/en_US.UTF-8/' /etc/locale.gen"
    arch_chroot "sed -i 's/#en_US.UTF-8/en_US.UTF-8/' /etc/locale.gen"
    arch_chroot "locale-gen"
}

configure_mkinitcpio() {
    echo "Configuring mkinitcpio"

    # if LUKS hooks: base systemd keyboard autodetect modconf block sd-vconsole sd-encrypt sd-lvm2 filesystems fsck
    sed -i '/^HOOKS/c\HOOKS=(base systemd keyboard autodetect modconf block sd-lvm2 filesystems fsck)' /mnt/etc/mkinitcpio.conf

    if [ "$(arch-chroot /mnt ls /boot | grep hardened -c)" -gt "0" ]; then
        arch_chroot "mkinitcpio -p linux-hardened"
    elif [ "$(arch-chroot /mnt ls /boot | grep lts -c)" -gt "0" ]; then
        arch_chroot "mkinitcpio -p linux-lts"
    else
        arch_chroot "mkinitcpio -p linux"
    fi
}

install_bootloader() {
    echo "Install bootloader"

    pacstrap /mnt grub os-prober
    if [[ $UEFI -eq 1 ]]; then
        pacstrap /mnt efibootmgr
    fi
}

configure_bootloader() {
    echo "Configure bootloader"

    if [[ $UEFI -eq 1 ]]; then
        arch_chroot "grub-install --target=x86_64-efi --efi-direcotry=/boot --bootloader-id=grub"
    else
        arch_chroot "grub-install --target=i386-pc --recheck --debug /dev/sda"
    fi

    arch_chroot "grub-mkconfig -o /boot/grub/grub.cfg"
}

configure_sudo() {
    echo "Configuring sudo..."
    arch_chroot "cp -v /etc/sudoers /etc/sudoers.orig"
    ## Uncomment to allow members of group wheel to execute any command
    arch_chroot "sed -i '/%wheel ALL=(ALL) ALL/s/^# //' /etc/sudoers"
}

configure_pacman() {
    echo "Configuring pacman..."
    arch_chroot "cp -v /etc/pacman.conf /etc/pacman.conf.orig"

    # Set up multilib
    if [[ $SYS_ARCH == x86_64 ]]; then
        local _has_multilib=`grep -n "\[multilib\]" /mnt/etc/pacman.conf | cut -f1 -d:`
        if [[ -z $_has_multilib ]]; then
            echo -e "\n[multilib]\nInclude = /etc/pacman.d/mirrorlist" >> /mnt/etc/pacman.conf
            echo -e '\nMultilib repository added into pacman.conf file'
        else
            sed -i "${_has_multilib}s/^#//" /mnt/etc/pacman.conf
            local _has_multilib=$(( ${_has_multilib} + 1 ))
            sed -i "${_has_multilib}s/^#//" /mnt/etc/pacman.conf
        fi
    fi

    # Setup archlinuxfr repository
    local _has_fr=`grep -n "\[archlinuxfr\]" /mnt/etc/pacman.conf | cut -f1 -d:`
    if [[ -z $_has_multilib ]]; then
        echo -e "\n[archlinuxfr]\nSigLevel = Never\nServer = https://repo.archlinux.fr/\$arch" >> /mnt/etc/pacman.conf
        echo -e '\nArchlinuxfr repository added into pacman.conf file'
    fi
}

root_password() {
    print_title "ROOT PASSWORD"
    print_warning "Enter your new root password"
    arch_chroot "passwd"
    while [[ $? -ne 0 ]]; do
        arch_chroot "passwd"
    done
}

setup_ansible_account() {
    print_title "ANSIBLE ACCOUNT"
    print_warning "Enter the password for the ansible account"

    arch_chroot "useradd -m -G wheel -s /bin/bash ansible"
    arch_chroot "passwd ansible"
    while [[ $? -ne 0 ]]; do
        arch_chroot "passwd ansible"
    done
    arch_chroot "chfn ansible -f Ansible"
}

wrap_up() {
    print_title "INSTALL COMPLETED"
    print_warning "After reboot you can configure users, install software.\nGenerally I pull an Ansible repository to then configure the machine."
}

### Main flow

print_title "https://github.com/brennanfee/provision-arch"
print_info "Provision Arch -> Automated script to install a base Arch system."
print_line
echo "Script can be cancelled at any time with CTRL+C"
pause_function

check_root
check_archlinux
check_boot_system
check_connection

loadkeys "$KEYMAP" # load the keymap

## Ask questions
ask_for_hostname
ask_for_main_disk
ask_for_second_disk
ask_for_kernel_level

print_summary

pacman -Syy

configure_mirrorlist
pause_if_debug

unmount_partitions
pause_if_debug
create_partitions
pause_if_debug
setup_lvm
pause_if_debug
format_partitions
pause_if_debug
mount_partitions
pause_if_debug

install_base_system
pause_if_debug
configure_keymap
pause_if_debug
configure_fstab
pause_if_debug
configure_hostname
pause_if_debug
configure_timezone
pause_if_debug
configure_clock
pause_if_debug
configure_locale
pause_if_debug
configure_mkinitcpio
pause_if_debug

install_bootloader
pause_if_debug
configure_bootloader
pause_if_debug

configure_sudo
pause_if_debug
configure_pacman
pause_if_debug

root_password
pause_if_debug
setup_ansible_account
pause_if_debug
wrap_up

